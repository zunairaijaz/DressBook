"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./lib/cart.ts":
/*!*********************!*\
  !*** ./lib/cart.ts ***!
  \*********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ GET),\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(app-pages-browser)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _lib_prisma__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/prisma */ \"(app-pages-browser)/./lib/prisma.ts\");\n\n// ðŸ›‘ CRITICAL FIX: Changed path to use alias @/lib/prisma. \n// If this fails, ensure you have \"paths\": { \"@/*\": [\"./*\"] } in your tsconfig.json.\n\n// ðŸ”‘ Placeholder User ID: In a real application, this value would be derived \n// from an authenticated session or a guest/anonymous token ID.\n// ðŸ”´ FIX THIS: The ID below MUST exist in your 'User' table to avoid the P2003 Foreign Key error.\nconst TEST_USER_ID = \"REPLACE_ME_WITH_A_VALID_USER_ID\"; // Example: \"usr_701d4a0f\"\n// --- GET all cart items ---\n// This function allows the client to retrieve the current cart contents.\nasync function GET() {\n    try {\n        const cartItems = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.cartItem.findMany({\n            where: {\n                userId: TEST_USER_ID\n            },\n            include: {\n                product: true\n            }\n        });\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(cartItems);\n    } catch (err) {\n        console.error(\"GET /api/cart error:\", err);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: \"Failed to fetch cart\"\n        }, {\n            status: 500\n        });\n    }\n}\n// --- Add to cart (POST) ---\n// This function handles adding a product to the cart or updating its quantity.\n// It expects a payload like the one in your Canvas: \n// { \"productId\": \"...\", \"quantity\": 1, \"selectedVariant\": {} }\nasync function POST(req) {\n    const userId = TEST_USER_ID; // Use the confirmed existing user ID\n    try {\n        // 1. Capture the payload fields from the request body.\n        const { productId: productOrId, quantity, selectedVariant } = await req.json();\n        // 2. Safely extract the product ID string.\n        const actualProductId = typeof productOrId === 'object' && productOrId !== null && 'id' in productOrId ? productOrId.id : productOrId;\n        // 3. Basic Validation\n        if (!actualProductId || !quantity) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Invalid request (missing productId or quantity)\"\n            }, {\n                status: 400\n            });\n        }\n        // 4. Check if the item already exists in the user's cart\n        const existing = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.cartItem.findFirst({\n            where: {\n                userId,\n                productId: actualProductId\n            }\n        });\n        if (existing) {\n            // 5. If it exists, update the quantity (add the new quantity to the existing one)\n            await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.cartItem.update({\n                where: {\n                    id: existing.id\n                },\n                data: {\n                    quantity: existing.quantity + quantity\n                }\n            });\n        } else {\n            // 6. If it does not exist, create a new cart item record\n            // This is the line that failed because the userId was missing from the User table.\n            await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.cartItem.create({\n                data: {\n                    userId,\n                    productId: actualProductId,\n                    quantity,\n                    selectedVariant: selectedVariant ? selectedVariant : null\n                }\n            });\n        }\n        // 7. Fetch and return the entire updated cart\n        const cart = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.cartItem.findMany({\n            where: {\n                userId\n            },\n            include: {\n                product: true\n            }\n        });\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(cart, {\n            status: existing ? 200 : 201\n        }); // 201 if created, 200 if updated\n    } catch (err) {\n        console.error(\"POST /api/cart fatal error:\", err);\n        console.error(\"Prisma Known Error Code: \".concat(err.code, \". Details: \").concat(err.message));\n        // Provide generic error feedback\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: \"Failed to add to cart\"\n        }, {\n            status: 500\n        });\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SSxDQUFDO1lBQUVHLE9BQU87UUFBd0IsR0FBRztZQUFFQyxRQUFRO1FBQUk7SUFDN0U7QUFDRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxpcXJhclxcRG93bmxvYWRzXFx0aGVfZHJlc3NCb29rXFxsaWJcXGNhcnQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmV4dFJlcXVlc3QsIE5leHRSZXNwb25zZSB9IGZyb20gXCJuZXh0L3NlcnZlclwiO1xyXG4vLyDwn5uRIENSSVRJQ0FMIEZJWDogQ2hhbmdlZCBwYXRoIHRvIHVzZSBhbGlhcyBAL2xpYi9wcmlzbWEuIFxyXG4vLyBJZiB0aGlzIGZhaWxzLCBlbnN1cmUgeW91IGhhdmUgXCJwYXRoc1wiOiB7IFwiQC8qXCI6IFtcIi4vKlwiXSB9IGluIHlvdXIgdHNjb25maWcuanNvbi5cclxuaW1wb3J0IHsgcHJpc21hIH0gZnJvbSBcIkAvbGliL3ByaXNtYVwiOyBcclxuXHJcbi8vIPCflJEgUGxhY2Vob2xkZXIgVXNlciBJRDogSW4gYSByZWFsIGFwcGxpY2F0aW9uLCB0aGlzIHZhbHVlIHdvdWxkIGJlIGRlcml2ZWQgXHJcbi8vIGZyb20gYW4gYXV0aGVudGljYXRlZCBzZXNzaW9uIG9yIGEgZ3Vlc3QvYW5vbnltb3VzIHRva2VuIElELlxyXG4vLyDwn5S0IEZJWCBUSElTOiBUaGUgSUQgYmVsb3cgTVVTVCBleGlzdCBpbiB5b3VyICdVc2VyJyB0YWJsZSB0byBhdm9pZCB0aGUgUDIwMDMgRm9yZWlnbiBLZXkgZXJyb3IuXHJcbmNvbnN0IFRFU1RfVVNFUl9JRCA9IFwiUkVQTEFDRV9NRV9XSVRIX0FfVkFMSURfVVNFUl9JRFwiOyAvLyBFeGFtcGxlOiBcInVzcl83MDFkNGEwZlwiXHJcblxyXG4vLyAtLS0gR0VUIGFsbCBjYXJ0IGl0ZW1zIC0tLVxyXG4vLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB0aGUgY2xpZW50IHRvIHJldHJpZXZlIHRoZSBjdXJyZW50IGNhcnQgY29udGVudHMuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBHRVQoKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGNhcnRJdGVtcyA9IGF3YWl0IHByaXNtYS5jYXJ0SXRlbS5maW5kTWFueSh7XHJcbiAgICAgIHdoZXJlOiB7IHVzZXJJZDogVEVTVF9VU0VSX0lEIH0sXHJcbiAgICAgIGluY2x1ZGU6IHsgcHJvZHVjdDogdHJ1ZSB9LCAvLyBBc3N1bWVzIGEgJ3Byb2R1Y3QnIHJlbGF0aW9uIGlzIGRlZmluZWQgaW4geW91ciBzY2hlbWFcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihjYXJ0SXRlbXMpO1xyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkdFVCAvYXBpL2NhcnQgZXJyb3I6XCIsIGVycik7XHJcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBlcnJvcjogXCJGYWlsZWQgdG8gZmV0Y2ggY2FydFwiIH0sIHsgc3RhdHVzOiA1MDAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyAtLS0gQWRkIHRvIGNhcnQgKFBPU1QpIC0tLVxyXG4vLyBUaGlzIGZ1bmN0aW9uIGhhbmRsZXMgYWRkaW5nIGEgcHJvZHVjdCB0byB0aGUgY2FydCBvciB1cGRhdGluZyBpdHMgcXVhbnRpdHkuXHJcbi8vIEl0IGV4cGVjdHMgYSBwYXlsb2FkIGxpa2UgdGhlIG9uZSBpbiB5b3VyIENhbnZhczogXHJcbi8vIHsgXCJwcm9kdWN0SWRcIjogXCIuLi5cIiwgXCJxdWFudGl0eVwiOiAxLCBcInNlbGVjdGVkVmFyaWFudFwiOiB7fSB9XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBQT1NUKHJlcTogTmV4dFJlcXVlc3QpIHtcclxuICBjb25zdCB1c2VySWQgPSBURVNUX1VTRVJfSUQ7IC8vIFVzZSB0aGUgY29uZmlybWVkIGV4aXN0aW5nIHVzZXIgSURcclxuICB0cnkge1xyXG4gICAgLy8gMS4gQ2FwdHVyZSB0aGUgcGF5bG9hZCBmaWVsZHMgZnJvbSB0aGUgcmVxdWVzdCBib2R5LlxyXG4gICAgY29uc3QgeyBwcm9kdWN0SWQ6IHByb2R1Y3RPcklkLCBxdWFudGl0eSwgc2VsZWN0ZWRWYXJpYW50IH0gPSBhd2FpdCByZXEuanNvbigpO1xyXG5cclxuICAgIC8vIDIuIFNhZmVseSBleHRyYWN0IHRoZSBwcm9kdWN0IElEIHN0cmluZy5cclxuICAgIGNvbnN0IGFjdHVhbFByb2R1Y3RJZCA9IFxyXG4gICAgICAodHlwZW9mIHByb2R1Y3RPcklkID09PSAnb2JqZWN0JyAmJiBwcm9kdWN0T3JJZCAhPT0gbnVsbCAmJiAnaWQnIGluIHByb2R1Y3RPcklkKSBcclxuICAgICAgICA/IHByb2R1Y3RPcklkLmlkIFxyXG4gICAgICAgIDogcHJvZHVjdE9ySWQ7XHJcblxyXG4gICAgLy8gMy4gQmFzaWMgVmFsaWRhdGlvblxyXG4gICAgaWYgKCFhY3R1YWxQcm9kdWN0SWQgfHwgIXF1YW50aXR5KSB7XHJcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcclxuICAgICAgICB7IGVycm9yOiBcIkludmFsaWQgcmVxdWVzdCAobWlzc2luZyBwcm9kdWN0SWQgb3IgcXVhbnRpdHkpXCIgfSwgXHJcbiAgICAgICAgeyBzdGF0dXM6IDQwMCB9XHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIDQuIENoZWNrIGlmIHRoZSBpdGVtIGFscmVhZHkgZXhpc3RzIGluIHRoZSB1c2VyJ3MgY2FydFxyXG4gICAgY29uc3QgZXhpc3RpbmcgPSBhd2FpdCBwcmlzbWEuY2FydEl0ZW0uZmluZEZpcnN0KHtcclxuICAgICAgd2hlcmU6IHsgdXNlcklkLCBwcm9kdWN0SWQ6IGFjdHVhbFByb2R1Y3RJZCB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKGV4aXN0aW5nKSB7XHJcbiAgICAgIC8vIDUuIElmIGl0IGV4aXN0cywgdXBkYXRlIHRoZSBxdWFudGl0eSAoYWRkIHRoZSBuZXcgcXVhbnRpdHkgdG8gdGhlIGV4aXN0aW5nIG9uZSlcclxuICAgICAgYXdhaXQgcHJpc21hLmNhcnRJdGVtLnVwZGF0ZSh7XHJcbiAgICAgICAgd2hlcmU6IHsgaWQ6IGV4aXN0aW5nLmlkIH0sXHJcbiAgICAgICAgZGF0YTogeyBxdWFudGl0eTogZXhpc3RpbmcucXVhbnRpdHkgKyBxdWFudGl0eSB9LFxyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIDYuIElmIGl0IGRvZXMgbm90IGV4aXN0LCBjcmVhdGUgYSBuZXcgY2FydCBpdGVtIHJlY29yZFxyXG4gICAgICAvLyBUaGlzIGlzIHRoZSBsaW5lIHRoYXQgZmFpbGVkIGJlY2F1c2UgdGhlIHVzZXJJZCB3YXMgbWlzc2luZyBmcm9tIHRoZSBVc2VyIHRhYmxlLlxyXG4gICAgICBhd2FpdCBwcmlzbWEuY2FydEl0ZW0uY3JlYXRlKHtcclxuICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICB1c2VySWQsXHJcbiAgICAgICAgICBwcm9kdWN0SWQ6IGFjdHVhbFByb2R1Y3RJZCxcclxuICAgICAgICAgIHF1YW50aXR5LFxyXG4gICAgICAgICAgc2VsZWN0ZWRWYXJpYW50OiBzZWxlY3RlZFZhcmlhbnQgPyBzZWxlY3RlZFZhcmlhbnQgOiBudWxsLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDcuIEZldGNoIGFuZCByZXR1cm4gdGhlIGVudGlyZSB1cGRhdGVkIGNhcnRcclxuICAgIGNvbnN0IGNhcnQgPSBhd2FpdCBwcmlzbWEuY2FydEl0ZW0uZmluZE1hbnkoe1xyXG4gICAgICB3aGVyZTogeyB1c2VySWQgfSxcclxuICAgICAgaW5jbHVkZTogeyBwcm9kdWN0OiB0cnVlIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oY2FydCwgeyBzdGF0dXM6IGV4aXN0aW5nID8gMjAwIDogMjAxIH0pOyAvLyAyMDEgaWYgY3JlYXRlZCwgMjAwIGlmIHVwZGF0ZWRcclxuICB9IGNhdGNoIChlcnI6IGFueSkgeyBcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJQT1NUIC9hcGkvY2FydCBmYXRhbCBlcnJvcjpcIiwgZXJyKTtcclxuICAgIGNvbnNvbGUuZXJyb3IoYFByaXNtYSBLbm93biBFcnJvciBDb2RlOiAke2Vyci5jb2RlfS4gRGV0YWlsczogJHtlcnIubWVzc2FnZX1gKTtcclxuXHJcbiAgICAvLyBQcm92aWRlIGdlbmVyaWMgZXJyb3IgZmVlZGJhY2tcclxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IGVycm9yOiBcIkZhaWxlZCB0byBhZGQgdG8gY2FydFwiIH0sIHsgc3RhdHVzOiA1MDAgfSk7XHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJOZXh0UmVzcG9uc2UiLCJwcmlzbWEiLCJURVNUX1VTRVJfSUQiLCJHRVQiLCJjYXJ0SXRlbXMiLCJjYXJ0SXRlbSIsImZpbmRNYW55Iiwid2hlcmUiLCJ1c2VySWQiLCJpbmNsdWRlIiwicHJvZHVjdCIsImpzb24iLCJlcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJzdGF0dXMiLCJQT1NUIiwicmVxIiwicHJvZHVjdElkIiwicHJvZHVjdE9ySWQiLCJxdWFudGl0eSIsInNlbGVjdGVkVmFyaWFudCIsImFjdHVhbFByb2R1Y3RJZCIsImlkIiwiZXhpc3RpbmciLCJmaW5kRmlyc3QiLCJ1cGRhdGUiLCJkYXRhIiwiY3JlYXRlIiwiY2FydCIsImNvZGUiLCJtZXNzYWdlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/cart.ts\n"));

/***/ })

});